---
# ------------------------------------------------------------------------
# Telekom Security - Compliance Automation - Compliance Checks
# Linux OS for Servers (3.65)
# Tasks: 01 Basic Hardening
# ------------------------------------------------------------------------

# ========================================================================
# Verification if playbook is started with '--check' option. If not throw
# error and end play!
- fail:
    msg: "WARNING: Playbooks for compliance checks must be started with '--check' option!"
  when: ansible_check_mode == false
# ========================================================================

# Req 1: Unused services and protocols must be deactivated.

- block:
    - name: req-001.1 check for open tcp ports
      shell: ss -nlt 2>/dev/null | awk '($1 == "LISTEN" && $4 !~ /127.0.0.*.:./ && $4 !~ /::*.:./) {print $4}' | sed 's/.*://' | sort -nu
      register: open_tcp_ports
      changed_when: false
      check_mode: no
    - set_fact:
        check_tcp: '{{ open_tcp_ports.stdout_lines | difference(tcp_services) }}'
    - set_fact: count_tcp=0
    - set_fact: count_tcp={{ count_tcp | int + 1 }}
      with_items: "{{ check_tcp }}"
    - fail:
        msg: "Found {{ count_tcp }} open TCP ports!"
      when: count_tcp != "0"
  rescue:
     - debug:
         msg: "Req-001 (1/2): FAILED"

- block:
    - name: req-001.2 check for open UDP ports
      shell: ss -nlu 2>/dev/null | awk '($1 == "UNCONN" && $4 !~ /127.0.0.*.:./ && $4 !~ /::*.:./) {print $4}' | sed 's/.*://' | sort -nu
      register: open_udp_ports
      changed_when: false
      check_mode: no
    - set_fact:
        check_udp: '{{ open_udp_ports.stdout_lines | difference(udp_services) }}'
    - set_fact: count_udp=0
    - set_fact: count_udp={{ count_udp | int + 1 }}
      with_items: "{{ check_udp }}"
    - fail:
        msg: "Found {{ count_udp }} open UDP ports!"
      when: count_udp != "0"
  rescue:
     - debug:
         msg: "Req-001 (2/2): FAILED"

# Req 2: The reachability of services must be restricted.

- block:
    - name: req-002.1 generate dummy failure message
      fail:
        msg: "Req 2 can not be checked automatically. Please do manual check!"
  rescue:
    - debug:
        msg: "Req-002 (1/1): FAILED"

# Req 3: Unused software must not be installed or must be uninstalled.

- block:
    - name: req-003.1 uninstall servers
      package:
        name: '{{ item }}'
        state: absent
      with_items: '{{ servers }}'
      register: check_servers
      failed_when: check_servers.changed
  rescue:
      - debug:
          msg: "Req-003 (1/2): FAILED"
  when: uninstall_servers

- block:
    - name: req-003.2 uninstall clients
      package:
        name: '{{ item }}'
        state: absent
      with_items: '{{ clients }}'
      register: check_clients
      failed_when: check_clients.changed
  rescue:
    - debug:
        msg: "Req-003 (2/2): FAILED"
  when: uninstall_clients

# Req 4:	Unused filesystems must be disabled.

- block:
    - name: req-004.1 check for modprobe file
      stat:
        path: '/etc/modprobe.d/disable.conf'
      register: check_file
      failed_when: check_file.stat.exists == false
    - name: req-004.4 check modprobe file for unused filesystems
      lineinfile:
        path: '/etc/modprobe.d/disable.conf'
        line: "install {{ item }} /bin/true"
        state: present
      register: check_modprobe
      failed_when: (check_modprobe is changed)
      with_items: "{{ filesystems }}"
      when: check_file.stat.exists
  rescue:
    - debug:
        msg: "Req-004 (1/2): FAILED"
  when: disable_filesystems

- block:
  - name: req-004.2 check loaded kernel modules
    modprobe:
      name: '{{ item }}'
      state: absent
    register: check_modules
    failed_when: check_modules.changed
    with_items:
      - "{{ filesystems }}"
  rescue:
    - debug:
        msg: "Req-004 (2/2): FAILED"
  when: disable_filesystems

# Req 5:	Dedicated partitions must be used for growing content that can
# influence the availability of the system.

- block:
    - name: req-005.1 check partitions
      lineinfile:
        path: '/etc/fstab'
        line: "{{item}} "
        state: present
      register: check_partitions
      failed_when: check_partitions.changed
      with_items:
        - "{{ partitions }}"
  rescue:
    - debug:
        msg: "Req-005 (1/1): FAILED"
  when: config_partitions

# Req 6:	Parameters nodev, nosuid and noexec must be set for partitions where
# this is applicable.

- block:
    - name: req-006.1 generate dummy failure message
      fail:
        msg: "Req 6 can not be checked automatically. Please do manual check!"
  rescue:
    - debug:
        msg: "Req-006 (1/1): FAILED"

# Req 7:	Automounting must be disabled.

- block:
    - name: req-007.1 uninstall autofs
      package:
        name: 'autofs'
        state: absent
      register: check_autofs
      failed_when: check_autofs.changed
  rescue:
    - debug:
        msg: "Req-007 (1/1): FAILED"
  when: uninstall_autofs

# Req 8: The use of at/cron must be restricted to authorized users.

- block:
  - name: req-008.1 delete cron & at allow files
    file:
      path: "{{ item }}"
      state: absent
    register: check_deny
    failed_when: check_deny.changed
    with_items:
      - "/etc/cron.deny"
      - "/etc/at.deny"
  rescue:
    - debug:
        msg: "Req-008 (1/2): FAILED"
  when: config_cron

- block:
  - name: req-008.2 check if cron & at allow files exist
    stat:
      path: "{{ item }}"
    register: check_allow_files
    failed_when: not check_allow_files.stat.exists
    with_items:
      - "/etc/cron.allow"
      - "/etc/at.allow"
  - name: req-008.3 check permissions of cron & at allow files
    file:
      path: "{{ item }}"
      owner: root
      group: root
      mode:  "og-rwx"
    register: check_file_rights
    failed_when: check_file_rights.changed
    with_items:
      - "/etc/cron.allow"
      - "/etc/at.allow"
  rescue:
    - debug:
        msg: "Req-008 (2/2): FAILED"
  when: config_cron

# Req 9: Sticky bit must be set on all world-writable directories.

- block:
    - name: req-009.1 search for world-writable directories
      shell: df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -type d -perm -0002 \! -perm -1000 2>/dev/null
      register: check_directories
      failed_when: check_directories.stdout != ""
      changed_when: false
      check_mode: no
  rescue:
    - debug:
        msg: "Req-009 (1/1): FAILED"
  when: config_worldwritable_directories

# Req 10: No regular files that are world writable must exist.

- block:
    - name: req-010.1 search for world-writable files
      shell: df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -type f -perm -0002 2>/dev/null
      register: check_files
      failed_when: check_files.stdout != ""
      changed_when: false
      check_mode: no
  rescue:
    - debug:
        msg: "Req-010 (1/1): FAILED"
  when: config_worldwritable_files == true

# Req 11:	Passwords must be protected with an appropriate hashing function.

- block:
    - name: req-011.1 set password encryption to sha-512 in login.defs
      lineinfile:
        dest: '/etc/login.defs'
        state: present
        regexp: '^ENCRYPT_METHOD*'
        line: 'ENCRYPT_METHOD SHA512'
      register: check_pass_encrypt
      failed_when: check_pass_encrypt.changed
  rescue:
    - debug:
        msg: "Req-011 (1/3): FAILED"
  when: config_sha512

- block:
    - name: req-011.2 set max rounds for sha-512
      lineinfile:
        dest: '/etc/login.defs'
        state: present
        regexp: '^SHA_CRYPT_MAX_ROUNDS*'
        line: 'SHA_CRYPT_MAX_ROUNDS {{ sha512_rounds_max }}'
      register: check_rounds_max
      failed_when: check_rounds_max.changed
  rescue:
    - debug:
        msg: "Req-011 (2/3): FAILED"
  when: config_sha512

- block:
    - name: req-011.3 set min rounds for sha-512
      lineinfile:
        dest: '/etc/login.defs'
        state: present
        regexp: '^SHA_CRYPT_MIN_ROUNDS*'
        insertafter: '^ENCRYPT_METHOD SHA512'
        line: 'SHA_CRYPT_MIN_ROUNDS {{ sha512_rounds_min }}'
      register: check_rounds_min
      failed_when: check_rounds_min.changed
  rescue:
    - debug:
        msg: "Req-011 (3/3): FAILED"
  when: config_sha512

# Req 12: The default user umask must be 027 or more restrictive.

- block:
    - name: req-012.1 check default umask for users
      lineinfile:
        dest: '/etc/login.defs'
        line: 'UMASK {{ umask }}'
        regexp: '^UMASK'
        state: present
      register: check_umask
      failed_when: check_umask.changed
  rescue:
    - debug:
        msg: "Req-012 (1/1): FAILED"
  when: config_umask

# Req 13:	Not needed SUID and SGID bits must be removed from executables.

- block:
    - name: req-013.1 remove suid/sgid bit from binaries in blacklist
      file:
        path: '{{ item }}'
        mode: 'a-s'
        state: 'file'
        follow: 'yes'
      register: check_sbit
      failed_when: check_sbit.changed
      with_items:
        - "{{ suid_sgid_blacklist }}"
  rescue:
    - debug:
        msg: "Req-013 (1/2): FAILED"
  when: config_suid_sgid

- block:
    - name: req-013.2 find binaries with suid/sgid set
      shell: df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -type f \( -perm -4000 -o -perm -2000 \) -print 2>/dev/null
      register: sbit_binaries
      changed_when: false
      check_mode: no
    - name: req-013.3 combine found files with default whitelist
      set_fact:
        suid: '{{ sbit_binaries.stdout_lines | difference(suid_sgid_whitelist) }}'
    - name: req-013.4 remove suid/sgid bit from all binaries except whitelists
      file:
        path: '{{ item }}'
        mode: 'a-s'
        state: 'file'
        follow: 'yes'
      register: check_sbit_unknown
      failed_when: check_sbit_unknown.changed
      with_items:
        - "{{ suid }}"
  rescue:
    - debug:
        msg: "Req-013 (2/2): FAILED"
  when: config_suid_sgid

# Req 14:	Core dumps must be disabled.

- block:
    - name: req-014.1 create limits.d-directory
      file:
        path: '/etc/security/limits.d'
        state: directory
        owner: root
        group: root
        mode: 0755
      register: check_limitsd
      failed_when: check_limitsd.changed
  rescue:
    - debug:
        msg: "Req-014 (1/): FAILED"
  when: config_coredumps

- name: req-014.2 create file limits.conf
  template:
    src: 'limits-conf.j2'
    dest: '/etc/security/limits.d/10.hardcore.conf'
    owner: root
    group: root
    mode: 0440
  when: config_coredumps

- block:
    - name: req-014.3 check restriction of coredumps
      shell: grep "^*[[:space:]]"{{item}}"[[:space:]]core[[:space:]]0" /etc/security/limits.d/* 2>/dev/null
      register: check_coredumps
      failed_when: check_coredumps.stdout == ""
      changed_when: false
      check_mode: no
      with_items:
        - "hard"
        - "soft"
  rescue:
    - debug:
        msg: "Req-014 (2/3): FAILED"
  when: not check_limitsd.changed

- block:
    - name: reg-014.4 check sysctl-settings for coredumps
      sysctl:
        name: '{{ item.key }}'
        value: '{{ item.value }}'
        sysctl_set: yes
        state: present
        reload: yes
      register: check_sysctl
      failed_when: check_sysctl.changed
      with_dict: '{{ coredumps }}'
  rescue:
    - debug:
        msg: "Req-014 (3/3): FAILED"
  when: config_coredumps

# Req 15:	Protection against buffer overflows must be enabled.

- block:
    - name: req-015.1 check if nx is enabled in bios
      shell: dmesg | awk -F' ' '{if ($3 == "NX") print $7}'
      register: check_nx
      failed_when: check_nx.stdout != "active"
      changed_when: false
      check_mode: no
  rescue:
    - debug:
        msg: "Req-015 (1/2): FAILED"
  when: config_buffer_overflow_protection

- block:
    - name: reg-015.2 check sysctl-settings for buffer overflow protection
      sysctl:
        name: '{{ item.key }}'
        value: '{{ item.value }}'
        sysctl_set: yes
        state: present
        reload: yes
      register: check_sysctl
      failed_when: check_sysctl.changed
      with_dict: '{{ buffer_overflow_protection }}'
  rescue:
    - debug:
        msg: "Req-015 (2/2): FAILED"
  when: config_buffer_overflow_protection

# Req 16:	Prelink must not be used.

- block:
    - name: req-016.1 uninstall prelink
      package:
        name: 'prelink'
        state: absent
      register: check_prelink
      failed_when: check_prelink.changed
  rescue:
    - debug:
        msg: "Req-016 (1/1): FAILED"
  when: uninstall_prelink and ansible_os_family != "RedHat"

# Req 17:	IPv4 protocol stack must be securely configured.

- block:
    - name: req-017.1 change sysctl-settings for ipv4
      sysctl:
        name: '{{ item.key }}'
        value: '{{ item.value }}'
        sysctl_set: yes
        state: present
        reload: yes
      register: check_ipv4
      failed_when: check_ipv4.changed
      with_dict: '{{ network_config_ipv4 }}'
  rescue:
    - debug:
        msg: "Req-017 (1/1): FAILED"
  when: config_network_ipv4

# Req 18:	IPv6 protocol stack must be securely configured.

- block:
    - name: req-018.1 change sysctl-settings if ipv6 is disabled
      sysctl:
        name: '{{ item.key }}'
        value: '{{ item.value }}'
        sysctl_set: yes
        state: present
        reload: yes
      register: check_ipv6
      failed_when: check_ipv6.changed
      with_dict: '{{ network_config_ipv6_disabled }}'
  rescue:
    - debug:
        msg: "Req-018 (1/1): FAILED"
  when: config_network_ipv6 and not config_ipv6_enable

- block:
    - name: req-018.2 change sysctl-settings if ipv6 is enabled
      sysctl:
        name: '{{ item.key }}'
        value: '{{ item.value }}'
        sysctl_set: yes
        state: present
        reload: yes
      register: check_ipv6
      failed_when: check_ipv6.changed
      with_dict: '{{ network_config_ipv6_enabled }}'
  rescue:
    - debug:
        msg: "Req-018 (1/1): FAILED"
  when: config_network_ipv6 and
     ( config_ipv6_enable or config_mgmt_interface_ipv6 )

# Req 19:	Emerged vulnerabilities in software and hardware of a system must be
# fixed or protected against misuse.

- name: req-019.1 update repository cache (ubuntu)
  apt:
    upgrade: no
    update_cache: yes
    cache_valid_time: 3600
    force_apt_get: yes
  register: cache_update
  ignore_errors: yes
  changed_when: false
  when: ansible_os_family == "Debian"

- block:
    - name: req-019.2 check if not installed updates available
      shell: apt-get upgrade -s | awk '/upgraded,/ {print $1}'
      args:
        warn: false
      register: open_updates
      failed_when: open_updates.stdout != "0"
      changed_when: false
      check_mode: no
  rescue:
    - debug:
        msg: "Req-019 (1/1): FAILED"
  when: ansible_os_family == "Debian" and cache_update.changed

- block:
    - name: req-019.3 check if not installed updates available
      shell: yum check-update 2>/dev/null | grep -i "updates$" | wc -l
      args:
        warn: false
      register: open_updates
      failed_when: open_updates.stdout != "0"
      changed_when: false
      check_mode: no
  rescue:
    - debug:
        msg: "Req-019 (1/1): FAILED"
  when: ansible_os_family == "RedHat"

# Req 20: GPG check for repository server must be activated and corresponding
# keys for trustable repositories must be configured.

# Req 21:	User accounts must be used that allow unambiguous identification of
# the user.

# Needed for Req 21 & 22: calculates UID_MIN from /etc/login.defs
- name: get uid from file login.defs
  shell: awk '/^\s*UID_MIN\s*([0-9]*).*?$/ {print $2}' /etc/login.defs
  register: uid_min
  changed_when: false
  check_mode: no

- name: calculate uid_max from uid_min
  set_fact:
    uid_max: '{{ uid_min.stdout | int - 1 }}'
  changed_when: false
  when: uid_min is defined

- name: set uid_max if no login.defs exist
  set_fact:
    uid_max: "{{ uid_default }}"
  changed_when: false
  when: not uid_min

- block:
    - name: req-021.1 get all system accounts
      shell: awk -F':' '{ if ( $1 != "{{ ansible_user }}" && $3 >= {{ uid_max }} && $7 != "{{ nologin_path }}" ) print $1 }' /etc/passwd
      register: check_sys_accounts
      changed_when: false
      failed_when: check_sys_accounts.stdout != ""
      check_mode: no
  rescue:
     - debug:
        msg: "Req-021 (1/1): FAILED"

# Req 22:	System accounts must be non-login.

- block:
    - name: req-022.1 check for system accounts with login
      shell: awk -F':' '($1!="root" && $1!="sync" && $1!="shutdown" && $1!="halt" && $3<{{ uid_max }} && $7=="/bin/bash") {print $1}' /etc/passwd
      register: check_sys_user
      failed_when: check_sys_user.stdout != ""
      changed_when: false
      check_mode: no
  rescue:
    - debug:
        msg: "Req-022 (1/1): FAILED"
  when: config_nologin_sys_accounts

# Req 23:	User accounts must be protected against unauthorized usage by at least
# one authentication attribute.

- block:
    - name: req-023.1 check for user accounts without password
      shell: awk -F":" '($2 == "" && $2 != "!" && $2 !="*") {print $1}' /etc/shadow
      register: user_without_pw
      failed_when: user_without_pw.stdout != ""
      changed_when: false
      check_mode: no
  rescue:
    - debug:
        msg: "Req-023 (1/1): FAILED"
  when: config_user_without_pw

# Req 24:	User accounts with extensive rights must be protected with two
# authentication attributes.

- block:
    - name: req-024.1 generate dummy failure message
      fail:
        msg: "Req 24 can not be checked automatically. Please do manual check!"
  rescue:
    - debug:
        msg: "Req-024 (1/1): FAILED"
  when: ansible_check_mode

# Req 25:	The system must be connected to a central system for user administration.

- block:
    - name: req-025.1 generate dummy failure message
      fail:
        msg: "Req 25 can not be checked automatically. Please do manual check!"
  rescue:
    - debug:
        msg: "Req-025 (1/1): FAILED"
  when: ansible_check_mode

# Req 26:	Authentication must be used for single user mode.

- block:
    - name: req-26.1 check if root has a password set
      shell: grep "^root:[*\!]:" /etc/shadow
      register: check_root_pw
      failed_when: check_root_pw.stdout != ""
      changed_when: false
      check_mode: no
  rescue:
    - debug:
        msg: "Req-026 (1/1): FAILED"
  when: ansible_distribution == "Ubuntu" and
      ( config_single_user_mode and config_root_password )

- block:
    - name: req-026.2 set single user mode
      lineinfile:
        dest: '{{ item }}'
        state: present
        regexp: '^ExecStart=*'
        line: 'ExecStart=-/bin/sh -c "/usr/sbin/sulogin; /usr/bin/systemctl --fail --no-block default"'
      register: check_sum
      failed_when: check_sum.changed
      with_items:
        - "/usr/lib/systemd/system/rescue.service"
        - "/usr/lib/systemd/system/emergency.service"
  rescue:
    - debug:
        msg: "Req-026 (1/1): FAILED"
  when: ansible_os_family == "RedHat" and config_single_user_mode

# Req 27: The management of the operating system must be done via a dedicated
# management network which is independent from the production network.

- block:
    - name: req-027.1 check if management interface (ipv4) is enabled
      fail:
        msg: "Management interface for IPv4 is disabled."
      when: config_mgmt_interface_ipv4 == false
    - name: req-027.2 check if real IP address is set for mgmt
      fail:
        msg: "No IPv4 address is set for management interface."
      when: config_mgmt_interface_ipv4 == true and
            ( mgmt_interface_ipv4 == "0.0.0.0" or mgmt_interface_ipv4 == "" )
  rescue:
    - debug:
        msg: "Req-027 (1/2): FAILED"

- block:
    - name: req-027.2 check if management interface (ipv6) is enabled
      fail:
        msg: "Management interface for IPv6 is disabled."
      when: config_mgmt_interface_ipv6 == false
    - name: req-027.4 check if real IP address is set for mgmt
      fail:
        msg: "No IPv6 address is set for management interface."
      when: config_mgmt_interface_ipv6 == true and
            ( mgmt_interface_ipv6 == "::" or mgmt_interface_ipv6 == "" )
  rescue:
    - debug:
        msg: "Req-027 (2/2): FAILED"
  when: config_ipv6_enable

# Req 28:	Management services must be bound to the management network.

- block:
    - name: req-028.1 check if sshd is bind on ipv4 of mgmt interface
      lineinfile:
        path: '/etc/ssh/sshd_config'
        line: "{{ item }}"
        state: present
      register: check_ssh_mgmt_4
      failed_when: (check_ssh_mgmt_4 is changed)
      with_items:
        - "ListenAddress {{mgmt_interface_ipv4}}"
  rescue:
    - debug:
        msg: "Req-027 (1/2): FAILED"
  when: config_mgmt_interface_ipv4

- block:
    - name: req-028.2 check if sshd is bind on ipv6 of mgmt interface
      lineinfile:
        path: '/etc/ssh/sshd_config'
        line: "{{ item }}"
        state: present
      register: check_ssh_mgmt_6
      failed_when: (check_ssh_mgmt_6 is changed)
      with_items:
        - "ListenAddress {{mgmt_interface_ipv6}}"
  rescue:
    - debug:
        msg: "Req-028 (2/2): FAILED"
  when: config_ipv6_enable and config_mgmt_interface_ipv6

#<tbd>
#- block:
#    - name: req-028.3 check if ntp is bind on ipv4 of mgmt interface
#      lineinfile:
#        path: '/etc/ntp.conf'
#        line: "server {{ item }}"
#        state: present
#      register: check_ntp_mgmt_4
#      failed_when: (check_ntp_mgmt_4 is changed)
#      with_items:
#        - "interface listen {{mgmt_interface_ipv4}}"
#  rescue:
#    - debug:
#        msg: "Req-027 (3/4): FAILED"
#  when: check_ntp.changed == true and ntp_status.stat.exists == true
# New Var: ntp_server_enable

#- block:
#    - name: req-028.4 check if ntp is bind on ipv6 of mgmt interface
#      lineinfile:
#        path: '/etc/ntp.conf'
#        line: "server {{ item }}"
#        state: present
#      register: check_ntp_mgmt_6
#      failed_when: (check_ntp_mgmt_6 is changed)
#      with_items:
#        - "interface listen {{use_mgmt_interface_ipv6}}"
#  rescue:
#    - debug:
#        msg: "Req-027 (4/4): FAILED"
#  when: check_ntp.changed == true and
#       (ntp_status.stat.exists == true and config_ipv6_enable == true)

# Req 29: Encrypted protocols must be used for management access to administrate
# the operating system.

- block:
    - name: req-029.1 generate dummy failure message
      fail:
        msg: "Req 29 can not be checked automatically. Please do manual check!"
  rescue:
    - debug:
        msg: "Req-029 (1/1): FAILED"
